# Test task. SysGears.

## Task №1

#### Завдання:

Розробити додаток для конвертації між одиницями відстані з підтримкою метричної та імперської систем вимірювання. Співвідношення для конвертації ви можете взяти з таблиці. Початково додаток повинен розпізнавати метри (m), сантиметри (cm), дюйми (in) та фути (ft), і підтримувати конвертацію між будь-якими з цих одиниць виміру.
Також необхідно реалізувати можливість розширювати список одиниць, що підтримуються, шляхом задання правил конвертації за допомогою JSON файлу. Формат JSON файлу - на ваш розсуд. Для прикладу, розширте ваш додаток додавши в файл значення для міліметрів (mm), ярдів (yd) та кілометрів (km).

#### Вхідні параметри:

Об'єкт у форматі JSON, що містить відстань для конвертації (distance) зі значенням (value) та шкалою (unit), а також позначення одиниці виміру для шкали, в яку повинна бути зроблена конвертація (convertTo), наприклад:

```json
{ "distance": { "unit": "m", "value": 0.5 }, "convertTo": "ft" }
```

#### Вихідні дані:

Об'єкт у форматі JSON, що містить отримане значення відстані, округлене до сотих, а також позначення відповідної одиниці виміру, наприклад:

```json
{ "unit": "ft", "value": 1.64 }
```

#### Як запустити:

Було реалізовано 2 варіанти (з різними форматами правил конвертаціЇ):

- `npx ts-node .\task1\app.ts '{distance: {unit: m, value: 0.5}, convertTo: ft}'`
- `npx ts-node .\task1\app2.ts '{distance: {unit: m, value: 0.5}, convertTo: ft}'`

## Task №2

### Завдання:

Розробити простий додаток для сортування та відбору даних за визначеними правилами. Додаток повинен вміти працювати зі списками JSON об'єктів довільної структури, відбирати об'єкти, що містять ключі з відповідними значеннями, а також сортувати об'єкти за значенням, використовуючи природний порядок сортування.
Наприклад, якщо для даних виду:

```json
{
  "data": [
    { "name": "John", "email": "john2@mail.com" },
    { "name": "John", "email": "john1@mail.com" },
    { "name": "Jane", "email": "jane@mail.com" }
  ]
}
```

задати умову:

```json
{
  "condition": {
    "include": [{ "name": "John" }],
    "sortBy": ["email"]
  }
}
```

що містить два правила - `include` і `sortBy` (де правило `include` приймає набір пар ключ:значення для перевірки записів на відповідність, а правило `sortBy` приймає набір ключів для сортування), результатом буде об'єкт, що містить лише записи з ім'ям `John`, відсортовані по ключу `email`:

```json
{
  "result": [
    { "name": "John", "email": "john1@mail.com" },
    { "name": "John", "email": "john2@mail.com" }
  ]
}
```

Плануючи підхід до дизайну коду додатка, необхідно передбачити можливість розширення функціонала шляхом додавання у код нових “модулів” з правилами. Важливо, щоб усі модулі мали між собою ідентичну структуру, були ізольовані один від одного та іншого коду додатка, та взаємодіяли з основним кодом за єдиним принципом. Для прикладу, ви можете додати новий модуль з правилом exclude, яке буде відкидати записи, що містять ключі з певним значенням.

### Вхідні параметри:

JSON об'єкт зі списком даних (`data`), та умовою для обробки (`condition`):

```json
{
  "data": [
    { "user": "mike@mail.com", "rating": 20, "disabled": false },
    { "user": "greg@mail.com", "rating": 14, "disabled": false },
    { "user": "john@mail.com", "rating": 25, "disabled": true }
  ],
  "condition": { "exclude": [{ "disabled": true }], "sortBy": ["rating"] }
}
```

### Вихідні дані:

JSON об'єкт з даними отриманими після застосування умови обробки (result):

```json
{
  "result": [
    { "user": "greg@mail.com", "rating": 14, "disabled": false },
    { "user": "mike@mail.com", "rating": 20, "disabled": false }
  ]
}
```

#### Як запустити:

`npx ts-node .\task2\app.ts ./task2/input.json `

## Task №3

## Task №4
